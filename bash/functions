# vim: set et sw=2 sts=2 ft=sh:
function goto_fault_code()
{
  # $1==binary, $2=address
  path=$(addr2line -e $1 $2)
  vim $path
}

function vimrej ()
{
  vim -O ${1}{.rej,}
}

function _kubectx_proxy ()
{
  # Idea: overwrite this function in ~/.local/bash_functions
  return
}

function kubectx ()
{
  if [ -z "${1}" ]; then
    echo "Usage: kubectx <context>"
    return
  fi
  if [ "${1}" == "--clear" ]; then
    unset KUBECONFIG
    return
  fi
  local cluster="${1%%.kubeconfig}"
  local kubecfg=$(eval echo "~/kubeconfigs/${cluster}.kubeconfig")
  local legacy_kubecfg=$(eval echo "~/${cluster}.kubeconfig")
  if [ -f "${kubecfg}" ]; then
    export KUBECONFIG="${kubecfg}"
  elif [ -f "${legacy_kubecfg}" ]; then
    export KUBECONFIG="${legacy_kubecfg}"
  else
    echo "Unknown kubeconfig ${1}".
    return
  fi
  _kubectx_proxy "${cluster}"
  kubectl get nodes
}

function _complete_kubectx ()
{
  local cluster_list=$(find ~/.kube/configs -name '*.kubeconfig' -printf '%P ' | sed 's/\.kubeconfig//g')
  local cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( $(compgen -W "${cluster_list} --clear" -- $cur ) )
}

complete -F _complete_kubectx kubectx

oc_token() {
    oc login | grep https | sed -e 's#.*\(https://.*\)#\1#' | xargs x-www-browser --new-tab
}

oc_login() {
    if [ -z "$KUBECONFIG" ]; then
        echo "Select cluster first"
        return 1
    fi
    if [ -z "${https_proxy}" ]; then
        export https_proxy=$(yq '.clusters[0].cluster."proxy-url"//""' $KUBECONFIG)
        cleanup_proxy=yes
    fi
    if [ -n "${ocp_user}" ]; then
      oc login -u "${ocp_user}" "$@"
    else
      oc login "$@"
    fi
    if [ "$https_proxy" != "" ]; then
        yq -i '.clusters[0].cluster."proxy-url"=env(https_proxy)' $KUBECONFIG
    fi
    if [ -n "${cleanup_proxy:-}" ]; then
        unset https_proxy
    fi
}

[ -f ~/.local/bash_functions ] && . ~/.local/bash_functions
